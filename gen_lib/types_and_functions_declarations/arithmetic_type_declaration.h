#ifndef FIBONACHY_NIM_ARITHMETIC_TYPE_DECLARATION_H
#define FIBONACHY_NIM_ARITHMETIC_TYPE_DECLARATION_H
#include <math.h>
#include "type_declaration.h"
#include <string.h>
#include <stdlib.h>
#include "functions_extensions.h"
//its a method that enables for generalized structures such as vector to do some arithmetic work with
//their types without knowing about their types. The main functions that need to be implemented here
//these are addPolynom, subComplex, multPolynom, divComplex, sqrt, minus
//its not neccessary to declare this for all type, but only for types that it needs.
//types must provide their arithmetic functions in singular pattern:
//TN addPolynom##UCN(const void * arg1, const void * arg2) that creates object as a result of addition
//void addToComplex##UCN(void * dest, const void * arg) that surves as cumulative func
//all these patterns should be realized for addPolynom, subComplex, multPolynom, divComplex. For others its just the first one.
//not all types can have sqrt so just put assert(false)
//crucial that functions that returns TN creates them, so, if they own data in heap, pointers will be new, and data calloced

//also, all arithmetical types should provide functions null##UCN(), unit##UCN()  that returns value corresponding to 0 and 1

//for standard types such as double, int, etc, all functions generated by single macro

//note that binary functions at ArithmeticTypePresenterContainer don't make any callocs
//but they rewrite dest to some value that is created in arithms functions
//because of it they call destructor before every arithmetic functions

//every function null##UCN(), unit##UCN() makes a malloc

//for every arithmetic func there will be generated all its right-value variations

typedef void(*binary_function)(void * dest, const void * arg1, const void * arg2);
typedef void(*unary_function)(void * dest, const void * arg);

struct ArithmeticTypePresenterContainer_struct
{
    binary_function add, sub, mult, div;
    unary_function addTo, subTo, multTo, divTo;
    unary_function sqrt, minus;
    void *(*callocZeroValue)();
    void *(*callocUnitValue)();
};
typedef struct ArithmeticTypePresenterContainer_struct ArithmeticTypePresenter;

#define GENERATE_GENERAL_WRAPPING_BYNARY_FUNCTION(TN, UCN, FUNC) \
static inline void __##FUNC##UCN(void * dest, const void * a, const void * b) \
{                                                                \
/*its principal that it is not moving, because moving can destroy object, but it may be so dest == a or b, so it must be valid*/\
    TN buff = *(TN*)dest;\
    *((TN*)dest) = FUNC##UCN((const TN*)a, (const TN*)b);        \
    destruct##UCN(&buff);\
}                                          \
                                                                 \

#define GENERATE_GENERAL_WRAPPING_UNARY_CUMULATIVE_FUNCTION(TN, UCN, FUNC)   \
static inline void __##FUNC##To##UCN(void * dest, const void * a)            \
{                                                                            \
    FUNC##To##UCN((TN*)dest, (const TN*)a);                                                                            \
}
#define GENERATE_GENERAL_WRAPPING_UNARY_FUNCTION(TN, UCN, FUNC) \
static inline void __##FUNC##UCN(void * dest, const void * a)                                                                \
{                                                               \
    TN buff = *(TN*)dest;\
    *((TN*)dest) = FUNC##UCN((const TN*)a);                     \
    destruct##UCN(&buff);\
}



#define GENERATE_GENERAL_WRAPPING_VALUE_FUNCTIONS(TN, UCN) \
static inline void * __null##UCN()      {                   \
    TN * res = malloc(TYPE_##UCN()->element_size);                                              \
    *res = null##UCN();                                    \
    return (void*)res;                                     \
}                                                           \
static inline void * __unit##UCN()      {\
     TN * res = malloc(TYPE_##UCN()->element_size);                                             \
     *res = unit##UCN();                                   \
     return (void*)res;                             \
}


#define GENERATE_GENERAL_WRAPPING(TN, UCN) \
GENERATE_GENERAL_WRAPPING_BYNARY_FUNCTION(TN, UCN, add) \
GENERATE_GENERAL_WRAPPING_BYNARY_FUNCTION(TN, UCN, sub) \
GENERATE_GENERAL_WRAPPING_BYNARY_FUNCTION(TN, UCN, mult)\
GENERATE_GENERAL_WRAPPING_BYNARY_FUNCTION(TN, UCN, div) \
GENERATE_GENERAL_WRAPPING_UNARY_CUMULATIVE_FUNCTION(TN, UCN, add)                                           \
GENERATE_GENERAL_WRAPPING_UNARY_CUMULATIVE_FUNCTION(TN, UCN, sub)                                             \
GENERATE_GENERAL_WRAPPING_UNARY_CUMULATIVE_FUNCTION(TN, UCN, mult)                                             \
GENERATE_GENERAL_WRAPPING_UNARY_CUMULATIVE_FUNCTION(TN, UCN, div)                                             \
GENERATE_GENERAL_WRAPPING_UNARY_FUNCTION(TN, UCN, sqrt) \
GENERATE_GENERAL_WRAPPING_UNARY_FUNCTION(TN, UCN, minus)                                           \
GENERATE_GENERAL_WRAPPING_VALUE_FUNCTIONS(TN, UCN)



#define GENERATE_BINARY_FUNCTION_FOR_STANDARD_TYPE(TN, UCN, FUNC, OPERATOR) \
static inline TN FUNC##UCN(const TN * a, const TN * b)                     \
{\
    return (*a) OPERATOR (*b);                                                                           \
}

#define GENERATE_MATH_FUNCTION_FOR_STANDARD_TYPE(TN, UCN, FUNC, func_in_math) \
static inline TN FUNC##UCN(const TN * a)                       \
{                                                                             \
    return func_in_math((double)*a);\
}                                                                              \

#define GENERATE_CUMULATIVE_FUNCTION_FOR_STANDARD_TYPE(TN, UCN, FUNC, OPERATOR) \
static inline void FUNC##To##UCN( TN * d, const TN * a)\
{\
    *d OPERATOR##= *a;\
}
#define GENERATE_STANDART_MINUS_FUNCTION_FOR_STANDART_TYPE(TN, UCN)             \
static inline TN minus##UCN(const TN * val)                                   \
{\
    return -(*val);                                                             \
}

#define GENERATE_VALUE_FUNCTION_FOR_STANDARD_TYPE(TN, UCN) \
static inline TN null##UCN() {                             \
    return 0;                                              \
}                                                          \
static inline TN unit##UCN() {                             \
    return 1;                                              \
}                                                          \
static inline bool isNull##UCN(const TN * obj)                         \
{                                                          \
    return equal##UCN##LVRV(obj, 0);                                      \
}


#define GENERATE_ARITHMETICAL_FUNCTIONS_FOR_STANDARD_TYPE(TN, UCN) \
GENERATE_BINARY_FUNCTION_FOR_STANDARD_TYPE(TN, UCN, add, +)                       \
GENERATE_CUMULATIVE_FUNCTION_FOR_STANDARD_TYPE(TN, UCN, add, +)                     \
GENERATE_BINARY_FUNCTION_FOR_STANDARD_TYPE(TN, UCN, sub, -)                       \
GENERATE_CUMULATIVE_FUNCTION_FOR_STANDARD_TYPE(TN, UCN, sub, -)                 \
GENERATE_BINARY_FUNCTION_FOR_STANDARD_TYPE(TN, UCN, mult, *)                       \
GENERATE_CUMULATIVE_FUNCTION_FOR_STANDARD_TYPE(TN, UCN, mult, *)                 \
GENERATE_BINARY_FUNCTION_FOR_STANDARD_TYPE(TN, UCN, div, /)                       \
GENERATE_CUMULATIVE_FUNCTION_FOR_STANDARD_TYPE(TN, UCN, div, /)    \
GENERATE_MATH_FUNCTION_FOR_STANDARD_TYPE(TN, UCN, sqrt, sqrt)      \
GENERATE_STANDART_MINUS_FUNCTION_FOR_STANDART_TYPE(TN, UCN)                                                                   \
GENERATE_VALUE_FUNCTION_FOR_STANDARD_TYPE(TN, UCN)


#define GENERATE_RIGHT_VALUE_EXTENSIONS_TO_ARITHMETICAL_FUNCTIONS(TN, UCN) \
GENERATE_RIGHT_VALUE_BINARY_EXTENSIONS(TN, UCN, add, TN)                       \
GENERATE_RIGHT_VALUE_BINARY_EXTENSIONS(TN, UCN, sub, TN)                       \
GENERATE_RIGHT_VALUE_BINARY_EXTENSIONS(TN, UCN, mult, TN)                      \
GENERATE_RIGHT_VALUE_BINARY_EXTENSIONS(TN, UCN, div, TN)                       \
GENERATE_RIGHT_VALUE_UNARY_EXTENSIONS(TN, UCN, sqrt, TN)                   \
GENERATE_RIGHT_VALUE_UNARY_EXTENSIONS(TN, UCN, minus, TN)                  \
GENERATE_RIGHT_VALUE_CUMULATIVE_UNARY_EXTENSIONS_SE_NAMING(TN, UCN, addTo)           \
GENERATE_RIGHT_VALUE_CUMULATIVE_UNARY_EXTENSIONS_SE_NAMING(TN, UCN, subTo)           \
GENERATE_RIGHT_VALUE_CUMULATIVE_UNARY_EXTENSIONS_SE_NAMING(TN, UCN, multTo)           \
GENERATE_RIGHT_VALUE_CUMULATIVE_UNARY_EXTENSIONS_SE_NAMING(TN, UCN, divTo)




#define DECLARE_ARITHMETIC_TYPE(TN, UCN) \
static inline const ArithmeticTypePresenter* ARITHM_TYPE_##UCN() {\
      static const ArithmeticTypePresenter type = {&__add##UCN, &__sub##UCN, &__mult##UCN, &__div##UCN, &__addTo##UCN, &__subTo##UCN, &__multTo##UCN, &__divTo##UCN, &__sqrt##UCN, &__minus##UCN, &__null##UCN, &__unit##UCN}; \
      return &type;                      \
}

#define DECLARE_STANDARD_TYPE_AS_ARITHMETIC(TN, UCN) \
GENERATE_ARITHMETICAL_FUNCTIONS_FOR_STANDARD_TYPE(TN, UCN) \
GENERATE_GENERAL_WRAPPING(TN, UCN)    \
GENERATE_RIGHT_VALUE_EXTENSIONS_TO_ARITHMETICAL_FUNCTIONS(TN, UCN)\
DECLARE_ARITHMETIC_TYPE(TN,UCN)

#define DECLARE_TYPE_AS_ARITHMETIC(TN, UCN) \
GENERATE_GENERAL_WRAPPING(TN, UCN)          \
GENERATE_RIGHT_VALUE_EXTENSIONS_TO_ARITHMETICAL_FUNCTIONS(TN, UCN)                                            \
DECLARE_ARITHMETIC_TYPE(TN, UCN)



DECLARE_STANDARD_TYPE_AS_ARITHMETIC(int, Int)

DECLARE_STANDARD_TYPE_AS_ARITHMETIC(long long int, LongLongInt)

DECLARE_STANDARD_TYPE_AS_ARITHMETIC(float, Float)

DECLARE_STANDARD_TYPE_AS_ARITHMETIC(double, Double)

DECLARE_STANDARD_TYPE_AS_ARITHMETIC(double complex, Complex)


#define SIMPLE_TYPE_ADD(UCN, OPERAND1, OPERAND2) ((* OPERAND1) + (* OPERAND2))
#define SIMPLE_TYPE_SUB(UCN, OP1, OP2) ((* OP1) - (* OP2))
#define SIMPLE_TYPE_MULT(UCN, OP1, OP2) ((* OP1) * (* OP2))
#define SIMPLE_TYPE_DIV(UCN, OP1, OP2) ((* OP1) / (* OP2))

#define SIMPLE_TYPE_ADD_LVRV(UCN, OPERAND1, OPERAND2) ((* OPERAND1) + (OPERAND2))
#define SIMPLE_TYPE_SUB_LVRV(UCN, OP1, OP2) ((* OP1) - (OP2))
#define SIMPLE_TYPE_MULT_LVRV(UCN, OP1, OP2) ((* OP1) * (OP2))
#define SIMPLE_TYPE_DIV_LVRV(UCN, OP1, OP2) ((* OP1) / (OP2))

#define SIMPLE_TYPE_ADD_RVLV(UCN, OPERAND1, OPERAND2) ((OPERAND1) + (* OPERAND2))
#define SIMPLE_TYPE_SUB_RVLV(UCN, OP1, OP2) ((OP1) - (* OP2))
#define SIMPLE_TYPE_MULT_RVLV(UCN, OP1, OP2) ((OP1) * (* OP2))
#define SIMPLE_TYPE_DIV_RVLV(UCN, OP1, OP2) ((OP1) / (* OP2))

#define SIMPLE_TYPE_ADD_RV(UCN, OPERAND1, OPERAND2) ((OPERAND1) + (OPERAND2))
#define SIMPLE_TYPE_SUB_RV(UCN, OP1, OP2) ((OP1) - (OP2))
#define SIMPLE_TYPE_MULT_RV(UCN, OP1, OP2) ((OP1) * (OP2))
#define SIMPLE_TYPE_DIV_RV(UCN, OP1, OP2) ((OP1) / (OP2))

#define SIMPLE_TYPE_ADD_TO(UCN, OP1, OP2) ((* OP1) += (* OP2))
#define SIMPLE_TYPE_SUB_TO(UCN, OP1, OP2) ((* OP1) -= (* OP2))
#define SIMPLE_TYPE_MULT_TO(UCN, OP1, OP2) ((* OP1) *= (* OP2))
#define SIMPLE_TYPE_DIV_TO(UCN, OP1, OP2) ((* OP1) /= (* OP2))

#define SIMPLE_TYPE_ADD_TO_RV(UCN, OP1, OP2) ((* OP1) += (OP2))
#define SIMPLE_TYPE_SUB_TO_RV(UCN, OP1, OP2) ((* OP1) -= (OP2))
#define SIMPLE_TYPE_MULT_TO_RV(UCN, OP1, OP2) ((* OP1) *= (OP2))
#define SIMPLE_TYPE_DIV_TO_RV(UCN, OP1, OP2) ((* OP1) /= (OP2))



#define STRUCT_TYPE_ADD(UCN, OPERAND1, OPERAND2) add##UCN(OPERAND1, OPERAND2)
#define STRUCT_TYPE_SUB(UCN, OP1, OP2) sub##UCN(OP1, OP2)
#define STRUCT_TYPE_MULT(UCN, OP1, OP2) mult##UCN(OP1, OP2)
#define STRUCT_TYPE_DIV(UCN, OP1, OP2) div##UCN(OP1, OP2)

#define STRUCT_TYPE_ADD_LVRV(UCN, OPERAND1, OPERAND2) add##UCN##LVRV(OPERAND1, OPERAND2)
#define STRUCT_TYPE_SUB_LVRV(UCN, OP1, OP2) sub##UCN##LVRV(OP1, OP2)
#define STRUCT_TYPE_MULT_LVRV(UCN, OP1, OP2) mult##UCN##LVRV(OP1, OP2)
#define STRUCT_TYPE_DIV_LVRV(UCN, OP1, OP2) div##UCN##LVRV(OP1, OP2)

#define STRUCT_TYPE_ADD_RVLV(UCN, OPERAND1, OPERAND2) add##UCN##RVLV(OPERAND1, OPERAND2)
#define STRUCT_TYPE_SUB_RVLV(UCN, OP1, OP2) sub##UCN##RVLV(OP1, OP2)
#define STRUCT_TYPE_MULT_RVLV(UCN, OP1, OP2) mult##UCN##RVLV(OP1, OP2)
#define STRUCT_TYPE_DIV_RVLV(UCN, OP1, OP2) div##UCN##RVLV(OP1, OP2)

#define STRUCT_TYPE_ADD_RV(UCN, OPERAND1, OPERAND2) add##UCN##RV(OPERAND1, OPERAND2)
#define STRUCT_TYPE_SUB_RV(UCN, OP1, OP2) sub##UCN##RV(OP1, OP2)
#define STRUCT_TYPE_MULT_RV(UCN, OP1, OP2) mult##UCN##RV(OP1, OP2)
#define STRUCT_TYPE_DIV_RV(UCN, OP1, OP2) div##UCN##RV(OP1, OP2)


#define STRUCT_TYPE_ADD_TO(UCN, OP1, OP2) addTo##UCN(OP1, OP2)
#define STRUCT_TYPE_SUB_TO(UCN, OP1, OP2) subTo##UCN(OP1, OP2)
#define STRUCT_TYPE_MULT_TO(UCN, OP1, OP2) multTo##UCN(OP1, OP2)
#define STRUCT_TYPE_DIV_TO(UCN, OP1, OP2) divTo##UCN(OP1, OP2)


#define STRUCT_TYPE_ADD_TO_RV(UCN, OP1, OP2) addTo##UCN##RV(OP1, OP2)
#define STRUCT_TYPE_SUB_TO_RV(UCN, OP1, OP2) subTo##UCN##RV(OP1, OP2)
#define STRUCT_TYPE_MULT_TO_RV(UCN, OP1, OP2) multTo##UCN##RV(OP1, OP2)
#define STRUCT_TYPE_DIV_TO_RV(UCN, OP1, OP2) divTo##UCN##RV(OP1, OP2)



#endif //FIBONACHY_NIM_ARITHMETIC_TYPE_DECLARATION_H
